<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>贪吃蛇</title>
<style>
  :root { color-scheme: dark; }
  body {
    margin: 0;
    min-height: 100vh;
    display: grid;
    place-items: center;
    background: radial-gradient(1200px 600px at 80% -200px, #1f2937 0%, #0b1220 60%, #080b14 100%);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
    color: #e5e7eb;
  }
  .wrap { width: 520px; max-width: 92vw; }
  h1 { margin: 0 0 8px; font-size: 22px; letter-spacing: 0.5px; }
  .hud {
    display: flex; gap: 12px; align-items: center; margin-bottom: 8px;
    font-size: 14px; color: #93c5fd;
  }
  .hud .val { color: #fef3c7; font-weight: 700; }
  canvas {
    width: 100%;
    height: auto;
    border: 1px solid #334155;
    background: #0b1220;
    box-shadow: 0 8px 30px rgba(0,0,0,0.35), inset 0 0 50px rgba(51,65,85,0.25);
  }
  .controls { display: flex; gap: 10px; margin-top: 10px; }
  button {
    appearance: none;
    border: 1px solid #334155;
    background: #0f172a;
    color: #e5e7eb;
    padding: 8px 14px;
    border-radius: 8px;
    font-size: 14px;
    cursor: pointer;
  }
  button:hover { border-color: #60a5fa; color: #fff; }
  .hint { margin-top: 6px; font-size: 12px; color: #94a3b8; }
</style>
</head>
<body>
  <div class="wrap">
    <h1>贪吃蛇</h1>
    <div class="hud">
      <div>分数：<span id="score" class="val">0</span></div>
      <div>最高分：<span id="high" class="val">0</span></div>
      <div>速度：<span id="spd" class="val">8</span></div>
      <div id="state" style="margin-left:auto;">状态：待开始</div>
    </div>
    <canvas id="game" width="480" height="480"></canvas>
    <div class="controls">
      <button id="toggle">开始</button>
      <button id="restart">重开</button>
    </div>
    <div class="hint">方向键/WASD 控制，空格暂停/继续，回车重开（边界联通）。偶现闪烁大红点：10秒限时、吃到多倍得分。</div>
  </div>

<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const tileSize = 24;
  let cols = 0, rows = 0;

  let snake = [];
  let dir = { x: 1, y: 0 };
  let bufferDir = { x: 1, y: 0 };
  const BONUS_MULT = 3;        // 大红点多倍得分倍数
  const BONUS_TTL_MS = 10000;  // 大红点存在时间：10秒
  const BONUS_PROB = 0.25;     // 随机出现概率：25%

  let food = { x: 0, y: 0, bonus: false, expireAt: 0 };
  let score = 0;
  let high = Number(localStorage.getItem('snake_high') || 0);
  let speed = 8;
  let running = false;
  let gameOver = false;

  let lastTime = performance.now();
  let stepAccum = 0;

  function resizeCanvas() {
    const size = Math.min(480, Math.floor(window.innerWidth * 0.92));
    const tiles = Math.max(10, Math.floor(size / tileSize));
    canvas.width = tiles * tileSize;
    canvas.height = tiles * tileSize;
    cols = Math.floor(canvas.width / tileSize);
    rows = Math.floor(canvas.height / tileSize);
  }

  function updateHUD() {
    document.getElementById('score').textContent = String(score);
    document.getElementById('high').textContent = String(high);
    document.getElementById('spd').textContent = String(speed);
    document.getElementById('toggle').textContent = running ? '暂停' : '开始';
    document.getElementById('state').textContent = gameOver ? '状态：游戏结束' : (running ? '状态：进行中' : '状态：暂停/待开始');
  }

  function placeFood() {
    while (true) {
      const x = Math.floor(Math.random() * cols);
      const y = Math.floor(Math.random() * rows);
      if (!snake.some(s => s.x === x && s.y === y)) {
        const isBonus = Math.random() < BONUS_PROB;
        const expireAt = isBonus ? performance.now() + BONUS_TTL_MS : 0;
        food = { x, y, bonus: isBonus, expireAt };
        return;
      }
    }
  }

  function reset() {
    running = false;
    gameOver = false;
    speed = 8;
    score = 0;
    snake = [{ x: Math.floor(cols / 2), y: Math.floor(rows / 2) }];
    dir = { x: 1, y: 0 };
    bufferDir = { x: 1, y: 0 };
    placeFood();
    lastTime = performance.now();
    stepAccum = 0;
    updateHUD();
    draw();
  }

  function setDir(nx, ny) {
    const newDir = { x: nx, y: ny };
    if (snake.length > 1 &&
        snake[1].x === snake[0].x + newDir.x &&
        snake[1].y === snake[0].y + newDir.y) return;
    bufferDir = newDir;
  }

  function step() {
    dir = bufferDir;
    let head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
    // 边界联通：越界后从另一侧出现
    head.x = (head.x + cols) % cols;
    head.y = (head.y + rows) % rows;
    const hitSelf = snake.some(s => s.x === head.x && s.y === head.y);
    if (hitSelf) {
      gameOver = true;
      running = false;
      high = Math.max(high, score);
      localStorage.setItem('snake_high', String(high));
      updateHUD();
      return;
    }
    snake.unshift(head);
    if (head.x === food.x && head.y === food.y) {
      const bonusActive = food.bonus && performance.now() < food.expireAt;
      score += bonusActive ? BONUS_MULT : 1;
      if (score % 5 === 0) speed += 1;
      high = Math.max(high, score);
      localStorage.setItem('snake_high', String(high));
      placeFood();
    } else {
      snake.pop();
    }
    updateHUD();
  }

  function drawCell(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
  }

  function draw() {
    ctx.fillStyle = '#0b1220';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = '#0f1a2e';
    ctx.lineWidth = 1;
    for (let x = 1; x < cols; x++) {
      ctx.beginPath(); ctx.moveTo(x * tileSize, 0); ctx.lineTo(x * tileSize, canvas.height); ctx.stroke();
    }
    for (let y = 1; y < rows; y++) {
      ctx.beginPath(); ctx.moveTo(0, y * tileSize); ctx.lineTo(canvas.width, y * tileSize); ctx.stroke();
    }

    // 食物绘制：大红点闪烁并限时
    const now = performance.now();
    if (food.bonus && now < food.expireAt) {
      const blink = Math.floor(now / 200) % 2 === 0; // 200ms 闪烁
      const size = blink ? tileSize : tileSize - 6;
      const off = (tileSize - size) / 2;
      ctx.fillStyle = blink ? '#ff3030' : '#ff6b6b';
      ctx.fillRect(food.x * tileSize + off, food.y * tileSize + off, size, size);
    } else {
      // 过期后降级为普通红点
      if (food.bonus && now >= food.expireAt) { food.bonus = false; }
      drawCell(food.x, food.y, '#ef4444');
    }
    for (let i = 0; i < snake.length; i++) {
      const c = i === 0 ? '#22c55e' : '#06b6d4';
      drawCell(snake[i].x, snake[i].y, c);
    }

    if (gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 28px system-ui, -apple-system, Segoe UI, Roboto';
      ctx.fillText('游戏结束', canvas.width / 2, canvas.height / 2 - 20);
      ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto';
      ctx.fillText('回车重开', canvas.width / 2, canvas.height / 2 + 12);
    }
  }

  function loop(ts) {
    const dt = (ts - lastTime) / 1000;
    lastTime = ts;
    if (running && !gameOver) {
      stepAccum += dt * speed;
      while (stepAccum >= 1) {
        step();
        stepAccum -= 1;
      }
    }
    draw();
    requestAnimationFrame(loop);
  }

  document.addEventListener('keydown', e => {
    switch (e.key) {
      case 'ArrowUp': case 'w': case 'W': setDir(0, -1); break;
      case 'ArrowDown': case 's': case 'S': setDir(0, 1); break;
      case 'ArrowLeft': case 'a': case 'A': setDir(-1, 0); break;
      case 'ArrowRight': case 'd': case 'D': setDir(1, 0); break;
      case ' ': if (!gameOver) { running = !running; updateHUD(); } break;
      case 'Enter': reset(); break;
    }
  });

  document.getElementById('toggle').addEventListener('click', () => {
    if (!gameOver) { running = !running; updateHUD(); }
  });
  document.getElementById('restart').addEventListener('click', reset);

  window.addEventListener('resize', () => {
    const oldCols = cols, oldRows = rows;
    resizeCanvas();
    const newCols = cols, newRows = rows;
    const scaleX = newCols / oldCols;
    const scaleY = newRows / oldRows;
    snake = snake.map(s => ({ x: Math.max(0, Math.min(newCols - 1, Math.round(s.x * scaleX))), y: Math.max(0, Math.min(newRows - 1, Math.round(s.y * scaleY))) }));
    food = { x: Math.max(0, Math.min(newCols - 1, Math.round(food.x * scaleX))), y: Math.max(0, Math.min(newRows - 1, Math.round(food.y * scaleY))) };
    draw();
  });

  resizeCanvas();
  reset();
  requestAnimationFrame(loop);
</script>
</body>
</html>